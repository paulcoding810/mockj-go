name: Docker Image Testing

on:
  workflow_call:
    inputs:
      image_ref:
        description: "Image reference to test"
        required: true
        type: string
      version:
        description: "Version being tested"
        required: false
        type: string
        default: "latest"

jobs:
  test-image:
    runs-on: ubuntu-latest

    services:
      mockj-go:
        image: ${{ inputs.image_ref }}
        ports:
          - 8080:8080
        env:
          SERVER_HOST: 0.0.0.0
          SERVER_PORT: 8080
          DATABASE_PATH: /app/data/mockj.db
          DATABASE_CLEANUP_INTERVAL: 1h
          RATE_LIMIT_ENABLED: true
          RATE_LIMIT_REQUESTS: 100
          RATE_LIMIT_WINDOW: 1m

    steps:
      - name: Wait for service to be ready
        run: |
          echo "‚è≥ Waiting for MockJ-Go to be ready..."
          sleep 30

      - name: Test health endpoint
        run: |
          echo "üè• Testing health endpoint..."
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)
          if [ "$response" = "200" ]; then
            echo "‚úÖ Health endpoint is working"
          else
            echo "‚ùå Health endpoint failed with status: $response"
            exit 1
          fi

      - name: Test API endpoints
        run: |
          echo "üîß Testing API endpoints..."

          # Test creating a JSON endpoint
          create_response=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d '{"json":"{\"test\": \"data\", \"version\": \"${{ inputs.version }}\"}", "password":"test123"}' \
            http://localhost:8080/api/json)

          echo "Create response: $create_response"

          # Extract ID from response
          id=$(echo "$create_response" | jq -r '.data.id')

          if [ -z "$id" ] || [ "$id" = "null" ]; then
            echo "‚ùå Failed to create JSON endpoint"
            exit 1
          fi

          echo "‚úÖ JSON endpoint created with ID: $id"

      - name: Test JSON retrieval
        run: |
          echo "üì• Testing JSON retrieval..."

          # Get the ID from previous step (would need to pass between steps)
          id=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d '{"json":"{\"test\": \"retrieve\"}", "password":"test123"}' \
            http://localhost:8080/api/json | jq -r '.data.id')

          if [ -z "$id" ] || [ "$id" = "null" ]; then
            echo "‚ùå Failed to get ID for retrieval test"
            exit 1
          fi

          get_response=$(curl -s http://localhost:8080/api/json/$id)
          echo "Get response: $get_response"

          # Check if response contains expected data
          if echo "$get_response" | jq -e '.data.json | contains("retrieve")' > /dev/null; then
            echo "‚úÖ JSON retrieval working"
          else
            echo "‚ùå JSON retrieval failed"
            exit 1
          fi

      - name: Test JSON update
        run: |
          echo "üìù Testing JSON update..."

          # Create endpoint for update test
          id=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d '{"json":"{\"test\": \"original\"}", "password":"test123"}' \
            http://localhost:8080/api/json | jq -r '.data.id')

          # Update the endpoint
          update_response=$(curl -s -X PUT \
            -H "Content-Type: application/json" \
            -d '{"json":"{\"test\": \"updated\"}", "password":"test123"}' \
            http://localhost:8080/api/json/$id)

          echo "Update response: $update_response"

          # Verify update worked
          if echo "$update_response" | jq -e '.data.json | contains("updated")' > /dev/null; then
            echo "‚úÖ JSON update working"
          else
            echo "‚ùå JSON update failed"
            exit 1
          fi

      - name: Test JSON deletion
        run: |
          echo "üóëÔ∏è Testing JSON deletion..."

          # Create endpoint for deletion test
          id=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d '{"json":"{\"test\": \"delete\"}", "password":"test123"}' \
            http://localhost:8080/api/json | jq -r '.data.id')

          # Delete the endpoint
          delete_response=$(curl -s -X DELETE \
            -H "Content-Type: application/json" \
            -d '{"password":"test123"}' \
            http://localhost:8080/api/json/$id)

          echo "Delete response: $delete_response"

          # Verify deletion worked
          if echo "$delete_response" | jq -e '.message | contains("deleted successfully")' > /dev/null; then
            echo "‚úÖ JSON deletion working"
          else
            echo "‚ùå JSON deletion failed"
            exit 1
          fi

      - name: Test endpoint expiration handling
        run: |
          echo "‚è∞ Testing expired endpoint handling..."

          # Create endpoint that expires in 1 hour
          id=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -d '{"json":"{\"test\": \"expire\"}", "password":"test123", "expires":"'$(date -u -d '+1 hour' +'%Y-%m-%dT%H:%M:%S.%3NZ')'"}' \
            http://localhost:8080/api/json | jq -r '.data.id')

          if [ -z "$id" ] || [ "$id" = "null" ]; then
            echo "‚ùå Failed to create expiring endpoint"
            exit 1
          fi

          # This endpoint should still be accessible (created within last hour)
          get_response=$(curl -s http://localhost:8080/api/json/$id)

          if echo "$get_response" | jq -e '.data.json | contains("expire")' > /dev/null; then
            echo "‚úÖ Expiring endpoint created successfully"
          else
            echo "‚ùå Expiring endpoint failed"
            exit 1
          fi

      - name: Test web interface
        run: |
          echo "üåê Testing web interface..."

          # Test if web interface loads
          web_response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/)

          if [ "$web_response" = "200" ]; then
            echo "‚úÖ Web interface is accessible"
          else
            echo "‚ùå Web interface not accessible (status: $web_response)"
            exit 1
          fi

      - name: Test rate limiting
        run: |
          echo "üö¶ Testing rate limiting..."

          # Make multiple rapid requests to test rate limiting
          success_count=0
          for i in {1..10}; do
            web_response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health)
            if [ "$web_response" = "200" ]; then
              success_count=$((success_count + 1))
            fi
            sleep 0.1
          done

          echo "Successful requests out of 10: $success_count"

          if [ $success_count -eq 10 ]; then
            echo "‚ö†Ô∏è Rate limiting may not be active (or configured for higher limits)"
          else
            echo "‚úÖ Rate limiting appears to be working"
          fi

  security-scan:
    runs-on: ubuntu-latest
    needs: test-image

    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ inputs.image_ref }}
          format: "sarif"
          output: "trivy-results.sarif"

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: "trivy-results.sarif"

  notify:
    needs: [test-image, security-scan]
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Test Summary
        run: |
          echo "üìä Docker Image Test Summary"
          echo "================================"
          echo "Image: ${{ inputs.image_ref }}"
          echo "Version: ${{ inputs.version }}"
          echo ""

          # Collect test results
          if [ "${{ needs.test-image.result }}" = "success" ]; then
            echo "‚úÖ Functional Tests: PASSED"
          else
            echo "‚ùå Functional Tests: FAILED"
          fi

          if [ "${{ needs.security-scan.result }}" = "success" ]; then
            echo "‚úÖ Security Scan: PASSED"
          else
            echo "‚ùå Security Scan: FAILED"
          fi
